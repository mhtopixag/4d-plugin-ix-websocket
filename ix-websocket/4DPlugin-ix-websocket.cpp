/* -------------------------------------------------------------------------------- # #  4DPlugin-ix-websocket.cpp #	source generated by 4D Plugin Wizard #	Project : ix-websocket #	author : miyako #	2019/07/08 #   # --------------------------------------------------------------------------------*/#include "4DPlugin-ix-websocket.h"#pragma mark -std::mutex message_list_mutex;/* for message_list; also used indirectly via event_queue */websocket_message_list *message_list = NULL;websocket_event_queue *event_queue = NULL;#pragma mark server callbacksvoid websocketserver_message(int i, std::shared_ptr<ix::WebSocket>p, ix::WebSocketMessagePtr msg) {    using namespace ix;    using namespace std;        websocket_server_ref *ref = websocket_server_ref::ref(i);        if(ref)    {        int j = ref->findClient(p);        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;        info["wireSize"] = (Json::Int)msg->wireSize;        info["binary"] = msg->binary;        info["data"] = msg->str;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(i, j, "message", context, window, process);            }    }    void websocketserver_ping(int i, std::shared_ptr<ix::WebSocket>p, ix::WebSocketMessagePtr msg) {        using namespace ix;    using namespace std;        websocket_server_ref *ref = websocket_server_ref::ref(i);        if(ref)    {        int j = ref->findClient(p);        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;        info["wireSize"] = (Json::Int)msg->wireSize;        info["binary"] = msg->binary;        info["data"] = msg->str;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(i, j, "ping", context, window, process);            }    }    void websocketserver_pong(int i, std::shared_ptr<ix::WebSocket>p, ix::WebSocketMessagePtr msg) {        using namespace ix;    using namespace std;        websocket_server_ref *ref = websocket_server_ref::ref(i);        if(ref)    {        int j = ref->findClient(p);        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;        info["wireSize"] = (Json::Int)msg->wireSize;        info["binary"] = msg->binary;        info["data"] = msg->str;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(i, j, "pong", context, window, process);            }    }    void websocketserver_fragment(int i, std::shared_ptr<ix::WebSocket>p, ix::WebSocketMessagePtr msg) {        using namespace ix;    using namespace std;        websocket_server_ref *ref = websocket_server_ref::ref(i);        if(ref)    {        int j = ref->findClient(p);        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;        info["wireSize"] = (Json::Int)msg->wireSize;        info["binary"] = msg->binary;        info["data"] = msg->str;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(i, j, "fragment", context, window, process);            }    }    void websocketserver_close(int i, std::shared_ptr<ix::WebSocket>p, ix::WebSocketCloseInfo *closeInfo) {        using namespace ix;    using namespace std;        websocket_server_ref *ref = websocket_server_ref::ref(i);        if(ref)    {        int j = ref->unregisterClient(p);        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;        info["code"] = closeInfo->code;        info["reason"] = closeInfo->reason;        info["remote"] = closeInfo->remote;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(i, j, "close", context, window, process);            }    }    void websocketserver_error(int i, std::shared_ptr<ix::WebSocket>p, ix::WebSocketErrorInfo *errorInfo) {        using namespace ix;    using namespace std;        websocket_server_ref *ref = websocket_server_ref::ref(i);        if(ref)    {        int j = ref->findClient(p);        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;                info["decompressionError"] = errorInfo->decompressionError;        info["reason"] = errorInfo->reason;        info["http_status"] = errorInfo->http_status;        info["wait_time"] = errorInfo->wait_time;        info["retries"] = errorInfo->retries;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(i, j, "error", context, window, process);            }    }    void websocketserver_open(int i, std::shared_ptr<ix::WebSocket>p, ix::WebSocketOpenInfo *openInfo) {        using namespace ix;    using namespace std;        websocket_server_ref *ref = websocket_server_ref::ref(i);        if(ref)    {        int j = ref->registerClient(p);        int window = ref->getWindow();        int process = ref->getProcess();                ix::WebSocketHttpHeaders::iterator it;        Json::Value info;        for (it = openInfo->headers.begin(); it != openInfo->headers.end(); it++)        {            info[it->first.c_str()] = it->second.c_str();        }                info["uri"] = openInfo->uri;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(i, j, "open", context, window, process);            }    }#pragma mark client callbacksvoid websocketclient_message(int i, ix::WebSocketMessagePtr msg) {        using namespace ix;    using namespace std;        websocket_client_ref *ref = websocket_client_ref::ref(i);        if(ref)    {        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;        info["wireSize"] = (Json::Int)msg->wireSize;        info["binary"] = msg->binary;        info["data"] = msg->str;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(0, i, "message", context, window, process);            }    }void websocketclient_ping(int i, ix::WebSocketMessagePtr msg) {        using namespace ix;    using namespace std;        websocket_client_ref *ref = websocket_client_ref::ref(i);        if(ref)    {        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;        info["wireSize"] = (Json::Int)msg->wireSize;        info["binary"] = msg->binary;        info["data"] = msg->str;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(0, i, "ping", context, window, process);            }    }void websocketclient_pong(int i, ix::WebSocketMessagePtr msg) {        using namespace ix;    using namespace std;        websocket_client_ref *ref = websocket_client_ref::ref(i);        if(ref)    {        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;        info["wireSize"] = (Json::Int)msg->wireSize;        info["binary"] = msg->binary;        info["data"] = msg->str;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(0, i, "pong", context, window, process);            }    }void websocketclient_fragment(int i, ix::WebSocketMessagePtr msg) {        using namespace ix;    using namespace std;        websocket_client_ref *ref = websocket_client_ref::ref(i);        if(ref)    {        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;        info["wireSize"] = (Json::Int)msg->wireSize;        info["binary"] = msg->binary;        info["data"] = msg->str;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(0, i, "fragment", context, window, process);            }    }void websocketclient_close(int i, ix::WebSocketCloseInfo *closeInfo) {        using namespace ix;    using namespace std;        websocket_client_ref *ref = websocket_client_ref::ref(i);        if(ref)    {        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;        info["code"] = closeInfo->code;        info["reason"] = closeInfo->reason;        info["remote"] = closeInfo->remote;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(0, i, "close", context, window, process);            }    }void websocketclient_error(int i, ix::WebSocketErrorInfo *errorInfo) {        using namespace ix;    using namespace std;        websocket_client_ref *ref = websocket_client_ref::ref(i);        if(ref)    {        int window = ref->getWindow();        int process = ref->getProcess();                Json::Value info;                info["decompressionError"] = errorInfo->decompressionError;        info["reason"] = errorInfo->reason;        info["http_status"] = errorInfo->http_status;        info["wait_time"] = errorInfo->wait_time;        info["retries"] = errorInfo->retries;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(0, i, "error", context, window, process);            }    }void websocketclient_open(int i, ix::WebSocketOpenInfo *openInfo) {        using namespace ix;    using namespace std;        websocket_server_ref *ref = websocket_server_ref::ref(i);        if(ref)    {        int window = ref->getWindow();        int process = ref->getProcess();                ix::WebSocketHttpHeaders::iterator it;        Json::Value info;        for (it = openInfo->headers.begin(); it != openInfo->headers.end(); it++)        {            info[it->first.c_str()] = it->second.c_str();        }                info["uri"] = openInfo->uri;                Json::StreamWriterBuilder builder;        std::string context = Json::writeString(builder, info);                std::lock_guard<std::mutex> lock(message_list_mutex);        message_list->addMessage(0, i, "open", context, window, process);            }    }#pragma mark -bool IsProcessOnExit(){    PA_Variable params[0];    PA_Variable result = PA_ExecuteCommandByID( /*Current process name*/1392, params, 0 );    PA_Unistring object = PA_GetStringVariable(result);    CUTF16String procName = CUTF16String(object.fString, object.fLength);    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");        return (!procName.compare(exitProcName));}void OnCloseProcess(){    if(IsProcessOnExit())    {        delete event_queue;        delete message_list;    }}void OnStartup() {        message_list = new websocket_message_list;    event_queue = new websocket_event_queue(message_list, &message_list_mutex);}void OnExit() {        websocket_client_ref::clearAll();    websocket_server_ref::clearAll();}#pragma mark -void PluginMain(PA_long32 selector, PA_PluginParameters params) {    	try	{        switch(selector)        {            case kInitPlugin :            case kServerInitPlugin :                OnStartup();                break;            case kDeinitPlugin :                OnExit();                break;                            case kCloseProcess :                OnCloseProcess();                break;                                // --- ix-websocket                            case 1 :                Websocket_client(params);                break;            case 2 :                Websocket_server(params);                break;            case 3 :                Websocket_client_start(params);                break;            case 4 :                Websocket_server_start(params);                break;            case 5 :                Websocket_client_stop(params);                break;            case 6 :                Websocket_server_stop(params);                break;            case 7 :                Websocket_client_send(params);                break;            case 8 :                Websocket_server_send(params);                break;            case 9 :                Websocket_client_clear(params);                break;            case 10 :                Websocket_server_clear(params);                break;            case 11 :                Websocket_server_clients(params);                break;            case 12 :                Websocket_server_messages(params);                break;            case 13 :                Websocket_client_messages(params);                break;        }	}	catch(...)	{	}}#pragma mark clientvoid Websocket_client(PA_PluginParameters params) {        using namespace ix;    using namespace std;        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_ObjectRef returnValue = PA_CreateObject();        if(returnValue)/* exit in PA_NewProcess thread */    {        websocket_client_ref *client_ref = new websocket_client_ref(param);                int ref = client_ref->getId();                client_ref->setParams(param);                client_ref->getParams(returnValue);                WebSocket *client = websocket_client_ref::find(ref);                client->setOnMessageCallback(                                     [ref](const ix::WebSocketMessagePtr& msg)                                     {                                         switch (msg->type) {                                             case WebSocketMessageType::Message:                                                 websocketclient_message(ref, msg);                                                 break;                                             case WebSocketMessageType::Open:                                                 websocketclient_open(ref, &msg->openInfo);                                                 break;                                             case WebSocketMessageType::Close:                                                 websocketclient_close(ref, &msg->closeInfo);                                                 break;                                             case WebSocketMessageType::Error:                                                 websocketclient_error(ref, &msg->errorInfo);                                                 break;                                             case WebSocketMessageType::Ping:                                                 websocketclient_ping(ref, msg);                                                 break;                                             case WebSocketMessageType::Pong:                                                 websocketclient_pong(ref, msg);                                                 break;                                             case WebSocketMessageType::Fragment:                                                 websocketclient_fragment(ref, msg);                                                 break;                                             default:                                                 break;                                         }                                                                              }                                     );                PA_ReturnObject(params, returnValue);    }}void Websocket_client_start(PA_PluginParameters params) {        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_ObjectRef returnValue = PA_CreateObject();        if(returnValue)/* exit in PA_NewProcess thread */    {        using namespace ix;        using namespace std;                WebSocket *client = websocket_client_ref::get(param);                if(client)        {            websocket_client_ref *ref = websocket_client_ref::ptr(param);                        if(ref)            {                ref->setParams(param);            }                        int timeout = 20;                        if(ob_is_defined(param, L"timeout"))            {                timeout = ob_get_n(param, L"timeout");            }                        WebSocketInitResult r = client->connect(timeout);                        ob_set_b(returnValue, L"success", r.success);            ob_set_n(returnValue, L"http_status", r.http_status);            ob_set_s(returnValue, L"errorStr", r.errorStr.c_str());            ob_set_s(returnValue, L"uri", r.uri.c_str());                        PA_ObjectRef header = PA_CreateObject();                        WebSocketHttpHeaders headers = r.headers;            WebSocketHttpHeaders::iterator it;                        for (it = headers.begin(); it != headers.end(); it++)            {                ob_set_s(header, it->first.c_str(), it->second.c_str());            }                        ob_set_o(returnValue, L"headers", header);                        if(r.success)            {                client->start();            }                    }                PA_ReturnObject(params, returnValue);    }}void Websocket_client_send(PA_PluginParameters params) {        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_ObjectRef returnValue = PA_CreateObject();        if(returnValue)/* exit in PA_NewProcess thread */    {        using namespace ix;        using namespace std;                websocket_client_ref *ref = websocket_client_ref::ptr(param);                if(ref)        {            ref->setParams(param);                        PA_Handle h = PA_GetBlobHandleParameter( params, 2 );                        if(h)            {                const string data = std::string((const char *)PA_LockHandle(h), PA_GetHandleSize(h));                                ref->send(param, data, returnValue);                                PA_UnlockHandle(h);            }                    }                PA_ReturnObject(params, returnValue);    }}void Websocket_client_stop(PA_PluginParameters params) {        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_ObjectRef returnValue = PA_CreateObject();        if(returnValue)/* exit in PA_NewProcess thread */    {        using namespace ix;        using namespace std;                WebSocket *client = websocket_client_ref::get(param);                if(client)        {            websocket_client_ref *ref = websocket_client_ref::ptr(param);                        if(ref)            {                ref->setParams(param);                ref->getParams(returnValue);            }                        client->stop();        }                PA_ReturnObject(params, returnValue);    }}void Websocket_client_clear(PA_PluginParameters params) {        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_ObjectRef returnValue = PA_CreateObject();        if(returnValue)/* exit in PA_NewProcess thread */    {        using namespace ix;        using namespace std;                websocket_client_ref::clear(param);                PA_ReturnObject(params, returnValue);    }}void Websocket_client_messages(PA_PluginParameters params) {        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_CollectionRef returnValue = PA_CreateCollection();        if(returnValue)/* exit in PA_NewProcess thread */    {        using namespace ix;        using namespace std;                websocket_client_ref *ref = websocket_client_ref::ptr(param);                if(ref)        {            int i = ref->getId();                        if (message_list_mutex.try_lock()) {                                std::vector<websocket_message *>::iterator it;                                for(it = message_list->begin(); it != message_list->end(); ++it)                {                    websocket_message *m = *it;                                        if((0 == m->getServer()) && (i == m->getClient()))                    {                        PA_ObjectRef message = PA_CreateObject();                        m->getValue(message);                                                PA_Variable v = PA_CreateVariable(eVK_Object);                        PA_SetObjectVariable(&v, message);                        PA_SetCollectionElement(returnValue, PA_GetCollectionLength(returnValue), v);                        PA_ClearVariable(&v);                    }                                    }                                message_list_mutex.unlock();            }         }                PA_ReturnCollection(params, returnValue);    }}#pragma mark servervoid Websocket_server(PA_PluginParameters params) {        using namespace ix;    using namespace std;        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_ObjectRef returnValue = PA_CreateObject();        if(returnValue)/* exit in PA_NewProcess thread */    {        websocket_server_ref *server_ref = new websocket_server_ref(param);                int ref = server_ref->getId();                server_ref->getParams(returnValue);                WebSocketServer *server = websocket_server_ref::find(ref);                server->setOnConnectionCallback(                                        [ref](shared_ptr<WebSocket> webSocket,                                              shared_ptr<ConnectionState> connectionState)                                        {                                            webSocket->setOnMessageCallback(                                                                            [ref,webSocket,connectionState](const WebSocketMessagePtr msg)                                                                            {                                                                                switch (msg->type) {                                                                                    case WebSocketMessageType::Message:                                                                                        websocketserver_message(ref, webSocket, msg);                                                                                        break;                                                                                    case WebSocketMessageType::Open:                                                                                        websocketserver_open(ref, webSocket, &msg->openInfo);                                                                                        break;                                                                                    case WebSocketMessageType::Close:                                                                                        websocketserver_close(ref, webSocket, &msg->closeInfo);                                                                                        break;                                                                                    case WebSocketMessageType::Error:                                                                                        websocketserver_error(ref, webSocket, &msg->errorInfo);                                                                                        break;                                                                                    case WebSocketMessageType::Ping:                                                                                        websocketserver_ping(ref, webSocket, msg);                                                                                        break;                                                                                    case WebSocketMessageType::Pong:                                                                                        websocketserver_pong(ref, webSocket, msg);                                                                                        break;                                                                                    case WebSocketMessageType::Fragment:                                                                                        websocketserver_fragment(ref, webSocket, msg);                                                                                        break;                                                                                }                                                                            }                                                                            );                                        }                                        );                PA_ReturnObject(params, returnValue);    }    }void Websocket_server_start(PA_PluginParameters params) {        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_ObjectRef returnValue = PA_CreateObject();        if(returnValue)/* exit in PA_NewProcess thread */    {        using namespace ix;        using namespace std;                WebSocketServer *server = websocket_server_ref::get(param);                if(server)        {            websocket_server_ref *ref = websocket_server_ref::ptr(param);                        if(ref)            {                ref->setParams(param);            }                        auto res = server->listen();                        if (res.first)            {                server->start();            }                        ob_set_b(returnValue, L"success", res.first);            ob_set_s(returnValue, L"message", res.second.c_str());        }                PA_ReturnObject(params, returnValue);    }}void Websocket_server_send(PA_PluginParameters params) {        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_CollectionRef returnValue = PA_CreateCollection();        if(returnValue)/* exit in PA_NewProcess thread */    {        using namespace ix;        using namespace std;                websocket_server_ref *ref = websocket_server_ref::ptr(param);                if(ref)        {            ref->setParams(param);                        PA_Handle h = PA_GetBlobHandleParameter( params, 2 );                        if(h)            {                const string data = std::string((const char *)PA_LockHandle(h), PA_GetHandleSize(h));                                ref->send(param, data, returnValue);                                PA_UnlockHandle(h);            }                    }                PA_ReturnCollection(params, returnValue);    }}void Websocket_server_stop(PA_PluginParameters params) {        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_ObjectRef returnValue = PA_CreateObject();        if(returnValue)/* exit in PA_NewProcess thread */    {        using namespace ix;        using namespace std;                WebSocketServer *server = websocket_server_ref::get(param);                if(server)        {            websocket_server_ref *ref = websocket_server_ref::ptr(param);                        if(ref)            {                ref->setParams(param);                ref->getParams(returnValue);            }                        server->stop();        }                PA_ReturnObject(params, returnValue);    }}void Websocket_server_clear(PA_PluginParameters params) {        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_ObjectRef returnValue = PA_CreateObject();        if(returnValue)/* exit in PA_NewProcess thread */    {        using namespace ix;        using namespace std;                websocket_server_ref::clear(param);                PA_ReturnObject(params, returnValue);    }}void Websocket_server_messages(PA_PluginParameters params) {        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_CollectionRef returnValue = PA_CreateCollection();        if(returnValue)/* exit in PA_NewProcess thread */    {        using namespace ix;        using namespace std;                websocket_server_ref *ref = websocket_server_ref::ptr(param);                if(ref)        {            int i = ref->getId();                        std::vector<websocket_message *>::iterator it;                        if (message_list_mutex.try_lock()) {                                for(it = message_list->begin(); it != message_list->end(); ++it)                {                    websocket_message *m = *it;                                        if(i == m->getServer())                    {                        PA_ObjectRef message = PA_CreateObject();                        m->getValue(message);                                                PA_Variable v = PA_CreateVariable(eVK_Object);                        PA_SetObjectVariable(&v, message);                        PA_SetCollectionElement(returnValue, PA_GetCollectionLength(returnValue), v);                        PA_ClearVariable(&v);                    }                                    }                message_list_mutex.unlock();            }        }        PA_ReturnCollection(params, returnValue);    }    }void Websocket_server_clients(PA_PluginParameters params) {        using namespace ix;    using namespace std;        PA_ObjectRef param = PA_GetObjectParameter(params, 1);    PA_CollectionRef returnValue = PA_CreateCollection();        if(returnValue)/* exit in PA_NewProcess thread */    {        websocket_server_ref *ref = websocket_server_ref::ptr(param);                if(ref)        {            std::set<int> clients;            if(ref->getClients(clients))            {                std::set<int>::iterator it;                for (it = clients.begin(); it != clients.end(); ++it)                {                    int client = *it;                    PA_Variable v = PA_CreateVariable(eVK_Longint);                    PA_SetLongintVariable(&v, client);                    PA_SetCollectionElement(returnValue, PA_GetCollectionLength(returnValue), v);                    PA_ClearVariable(&v);                }                            }                    }        PA_ReturnCollection(params, returnValue);    }    }